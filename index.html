<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã³ã‚æ¹–3cmé›»æ± ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ ä¸Šæ± ã®å€™è£œåœ°ã‚’æ¢ãã† ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ç‰ˆ </title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #inputGroup { display: none; } 
  
    #map { height: 500px; width: 1000px ; margin-bottom: 10px; }
body { font-family: sans-serif; line-height: 1.6; padding: 20px; margin: 0; }
.container {
  display: flex;
  flex-direction: row;
height: auto;      /* ã“ã‚ŒãŒä¸€ç•ªç´ ç›´ã€‚ã“ã‚Œã§å­è¦ç´ ã®é«˜ã•ã«ãƒ•ã‚£ãƒƒãƒˆ height: 90vh;*/  
  display: flex;
  box-sizing: border-box;
}
.map-block {
  flex: 1 1 0%;
  min-width: 600px;
  min-height: 600px;
  max-height: 600px;
  background: #dde8ff;
  display: flex;
  align-items: flex-start;
  justify-content: flex-start;
}
.result-block {
 max-height: 600px;   /* ã“ã‚Œã§æœ€å¤§é«˜ã•ã‚’åˆ¶é™ã§ãã‚‹ */
  overflow-y: auto;    /* ã¯ã¿å‡ºã—ãŸã‚‰ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
    width: 450px;
  max-width: 40vw;
  min-width: 300px;
  box-sizing: border-box;
  background: #fffbe0;
  border-left: 2px solid #b0a000;
  padding: 1.2em 1em 1em 1.5em;
  display: flex;
  flex-direction: column;
  font-size: 1.05em;
  overflow-y: auto;
}
.button-row {
  display: flex;
  gap: 0.7em;  /* ãƒœã‚¿ãƒ³ã®é–“ã«é©åº¦ãªç©ºã */
  margin-bottom: 8px; /* ãŠå¥½ã¿ã§ä¸‹ã®éš™é–“ */
}
#map {
  width: 100%;
  height: 600px;      /* å¿…è¦ã«å¿œã˜ã¦ */
}
#map.crosshair { cursor: crosshair !important; }
@media (max-width: 900px) {
  .container {
    flex-direction: column;
  }
  .map-block, .result-block {
    min-width: 0;
    max-width: 100vw;
    width: 100vw;
    min-height: 220px;
    max-height: unset;
  }
  #map {
    height: 400px;      /* ã‚¹ãƒãƒ›ã¯é«˜ã•æ§ãˆã‚æ¨å¥¨ */
    min-height: 200px;
    max-height: 600px;
  }
}
   .bar-container {
      position: relative; width: 80px; height: 100px; border: 1px solid #444;
      background-color: #f0f0f0; margin: 5x 5px 10px 0;
    }
    .bar { position: absolute; bottom: 0; width: 100%; transition: height 0.5s; }
    #lakeLevelBar { background-color: #0277bd; }
    #energyLevelBar { background-color: #e53935; }
    .bar-value-label {
      position: absolute; width: 50%; text-align: center; font-size: 0.8em;
      font-weight: bold; color: #000; top: 0; pointer-events: none;
    }
    .bar-label { text-align: left; font-size: 0.9em; }
    .bar-area { display: flex; gap: 20px; margin-top: 10px; }
    .bigslider {
      width: 400px;      /* ãŠå¥½ããªé•·ã•ã«ï¼ */
      max-width: 90%;   /* ç”»é¢ã®90%ã¾ã§å¯ */
    }
</style>
</head>
<body>
  <h2>ã³ã‚æ¹–3cmé›»æ± ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã€€ä¸Šæ± ã®å€™è£œåœ°ã‚’æ¢ãã† ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§GO</h2>
  <p>åœ°å›³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€æ¨™é«˜å·®ã¨ç™ºé›»é‡ã€çµç¶æ¹–æ°´ä½å·®ã€æœ€çŸ­æ°´éš›ã¾ã§ã®è·é›¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
  <div id="ctrl">
    <span><button id="befpb" onclick="befstep()"><<</button></span>
    <label  id="toukousen" >ç­‰é«˜ç·šå€¤: </label><input type="range" id="altSlider" min="0" max="128" value="9" class="bigslider">
    <span><button id="nextpb"  onclick="nextstep()">>></button></span>
    <span id="spnJS">90</span><div>ã€€</div>
  </div>
<div class="container">
  <div class="map-block">
    <div id="map"></div>
    <canvas id="contourCanvas" width="400" height="400" style="display:none"></canvas>
    <imgcanvas id="contourCanvas" width="6750" height="9000" style="display:none"></canvas>
  </div>
  <div class="result-block">
    <div>çµæœã®è¡¨ç¤ºã‚¨ãƒªã‚¢</div>
    <div class="info" id="coords">ç·¯åº¦ãƒ»çµŒåº¦ï¼š--</div>
    <div class="button-row">
    <button onclick="openGoogleMap(35.1608, 135.8703)">Google Maps</button>
    <button onclick="openGsiMap(35.0116, 135.7681)">å›½åœŸåœ°ç†é™¢åœ°å›³</button>
    <button id="doDAMPB" style="display:none" onclick="doDAM()"> ãƒ€ãƒ ä½œæˆ </button>
    <button id="DAMclearPB" style="display:none" onclick="clearLines()"> ãƒ€ãƒ æ¶ˆå» </button>
  </div>
    <div class="info" id="elevation">ä¸Šæ± æ¨™é«˜ï¼š-- m</div>
    <div class="info" id="drop">æœ‰åŠ¹è½å·®ï¼š-- m</div>
    <div class="info" id="energy">ä½ç½®ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼š-- GWh</div>  
    <div class="info" id="suii">çµç¶æ¹–æ°´ä½å·®ï¼š-- mm</div>
    <div class="info" id="distance">æœ€çŸ­è·é›¢ï¼š-- km</div>
    <div class="bar-area">
      <!-- ä»¥ä¸‹çœç•¥ï¼ˆæ£’ã‚°ãƒ©ãƒ•ãªã©ï¼‰ -->
      <div class="bar-container">
        <div id="lakeLevelBar" class="bar"></div>
        <div id="lakeValueLabel" class="bar-value-label"></div>
      </div>
      <div class="bar-label">æ°´ä½å¤‰å‹•ï¼ˆmmï¼‰</div>
      <div class="bar-container">
        <div id="energyLevelBar" class="bar"></div>
        <div id="energyValueLabel" class="bar-value-label"></div>
      </div>
      <div class="bar-label">ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆGWhï¼‰</div>
    </div>
    <div class="info" id="lH">æ¨™é«˜ã€€ã€€ã€€:-- m</div>
    <div class="info" id="damH">ãƒ€ãƒ é«˜ã•ï¼š-- m</div>
    <div class="info" id="damL">ãƒ€ãƒ é•·ã•ï¼š-- m</div>
    <div class="info" id="koA">ãƒ€ãƒ æ¹–é¢ç©ï¼š-- m</div>
    <div class="info" id="koV">ãƒ€ãƒ æ¹–ä½“ç©ï¼š-- m</div>
    <div class="info" id="koL">ãƒ€ãƒ æ¹–æœ€æ·±ï¼š-- m</div>
    <div class="info" id="enegy">ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆGWhï¼‰ï¼š-- GWh</div>

  </div>
</div>
<!--<canvas id="contourCanvas" width="6750" height="9000" style="display:none"></canvas> -->
</div><div id="ui-controls" style="background:#fff;padding:10px 20px;border-radius:10px;box-shadow:0 2px 12px #0001;max-width:420px;margin:16px auto 0;">
  <label>
    <input type="checkbox" id="pinSwitch" checked>
    ğŸ“ ãƒ”ãƒ³è¡¨ç¤ºON/OFF
  </label>
  <br>
 <label>
    <input type="checkbox" id="pinGamenSwitch" >
    ğŸ“ ãƒ”ãƒ³ç™»éŒ²ç”»é¢ã® è¡¨ç¤º/éè¡¨ç¤º åˆ‡æ›¿
  </label>
  <br>
  <label>
    <input type="checkbox" id="sliderSwitch" checked>
    ğŸšï¸ ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ»æ°´æ²¡ON/OFF
  </label>
  <br>
  <label>
    <input type="checkbox" id="damSwitch">
    ğŸ—ï¸ ãƒ€ãƒ å»ºè¨­ãƒ¢ãƒ¼ãƒ‰ON/OFF (â€»å·¥äº‹ä¸­ã§ã™)
  </label>
</div>
  <div id="inputGroup">
    <br><br>
    ã‚¿ã‚¤ãƒˆãƒ«ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ãƒ”ãƒ³ã®è‰²ã‚’æŒ‡å®šã—ã¦ã€€æ–°ã—ã„ãƒ”ãƒ³ã‚’ç™»éŒ²ã§ãã¾ã™<br>
    ã‚¿ã‚¤ãƒˆãƒ«: <input type="text" id="title"><br>
  <label>ã‚³ãƒ¡ãƒ³ãƒˆ:<br>
ã€€ã€€ã€€<textarea id="comment" rows="4" cols="40" placeholder="ã“ã“ã«è¤‡æ•°è¡Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›ã§ãã¾ã™"></textarea>
  </label><br>
  ãƒ”ãƒ³ã®è‰²: 
    <label><input type="radio" name="color" value="ğŸ”´ èµ¤" checked>ğŸ”´èµ¤</label>
    <label><input type="radio" name="color" value="ğŸ”µ é’">ğŸ”µé’</label>
    <label><input type="radio" name="color" value="ğŸŸ¢ ç·‘">ğŸŸ¢ç·‘</label>
    <label><input type="radio" name="color" value="ğŸŸ¡ é»„">ğŸŸ¡é»„</label><br><br>
  <button onclick="submitForm()">ãƒ”ãƒ³ã‚’ç™»éŒ²ã—ã¾ã™</button>ã€€ã€€Google ãƒ•ã‚©ãƒ¼ãƒ ãŒå‡ºã¦ãã¾ã™ãŒã³ã£ãã‚Šã—ãªã„ã§ã­<br><br>
  </div>
<!--  
    <div>
    <button onclick="toggleInputGroup()">ãƒ”ãƒ³ç™»éŒ²ç”»é¢ã® è¡¨ç¤º/éè¡¨ç¤º åˆ‡æ›¿</button>
  </div><br><br> 
-->
    <pre id="log"></pre>
    <div>
      <a class="btn" href="https://pgmatsuyama.github.io/biwako-denchi-kids/index.html" target="_blank">
         â†’ ã³ã‚æ¹–é›»æ± ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
      </a>
  </div>
<canvas id="profileChart" width="600" height="300"></canvas>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
<script src="https://cdn.rawgit.com/gpujs/gpu.js/45103b7f154a12ec639990c6896b21a053eb6a6c/bin/gpu.js"></script>
<script src="https://unpkg.com/marchingsquares@1.3.0/dist/marchingsquares.min.js"></script>
  <script>
   // ã‚·ãƒ¼ãƒˆã®CSVå…¬é–‹URLã«æ›¸ãæ›ãˆã¦ãã ã•ã„
    const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRoUhhqWmQWeIRV55mDeNJwIXT7haLHZPC518jyra7_f_rNd82wjcPTAcRXYeUFSwogdTIXrwNTH_xE/pub?output=csv';

const colorMap = {
  'ğŸ”´ èµ¤': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
  'ğŸ”µ é’': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
  'ğŸŸ¢ ç·‘': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
  'ğŸŸ¡ é»„': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-yellow.png'
};
/*
const colorMap = {
  'ğŸ”´ èµ¤': 'images/marker-icon-red.png',
  'ğŸ”µ é’': 'images/marker-icon-blue.png',
  'ğŸŸ¢ ç·‘': 'images/marker-icon-green.png',
  'ğŸŸ¡ é»„': 'images/marker-icon-yellow.png'
};
*/
const rawLakePoints = [
      // ã“ã“ã«120ç‚¹ã® { lat: ..., lng: ... } ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„
{ lat: 35.018088, lng:  135.863113},
{ lat: 35.036081, lng:  135.866547},
{ lat: 35.036081, lng:  135.866547},
{ lat: 35.059129, lng:  135.882339},
{ lat: 35.090037, lng:  135.900879},
{ lat: 35.108575, lng:  135.920792},
{ lat: 35.127160, lng:  135.926971},
{ lat: 35.133618, lng:  135.923538},
{ lat: 35.144567, lng:  135.925598},
{ lat: 35.155693, lng:  135.935555},
{ lat: 35.160886, lng:  135.926800},
{ lat: 35.170989, lng:  135.920191},
{ lat: 35.177304, lng:  135.917358},
{ lat: 35.190001, lng:  135.918732},
{ lat: 35.201153, lng:  135.925255},
{ lat: 35.205011, lng:  135.935211},
{ lat: 35.215179, lng:  135.942078},
{ lat: 35.221069, lng:  135.951347},
{ lat: 35.227239, lng:  135.962420},
{ lat: 35.239578, lng:  135.961905},
{ lat: 35.245607, lng:  135.970745},
{ lat: 35.260746, lng:  135.983877},
{ lat: 35.270978, lng:  136.003532},
{ lat: 35.278756, lng:  136.017952},
{ lat: 35.287233, lng:  136.017437},
{ lat: 35.297392, lng:  136.018467},
{ lat: 35.303836, lng:  136.031342},
{ lat: 35.302085, lng:  136.044216},
{ lat: 35.313012, lng:  136.058464},
{ lat: 35.315813, lng:  136.073484},
{ lat: 35.323587, lng:  136.077690},
{ lat: 35.330729, lng:  136.073313},
{ lat: 35.344790, lng:  136.069107},
{ lat: 35.355571, lng:  136.063957},
{ lat: 35.364951, lng:  136.052284},
{ lat: 35.373070, lng:  136.045418},
{ lat: 35.376709, lng:  136.035633},
{ lat: 35.386366, lng:  136.034260},
{ lat: 35.396442, lng:  136.034775},
{ lat: 35.403578, lng:  136.038208},
{ lat: 35.406570, lng:  136.046877},
{ lat: 35.413041, lng:  136.045675},
{ lat: 35.420525, lng:  136.045847},
{ lat: 35.426102, lng:  136.042156},
{ lat: 35.432536, lng:  136.039238},
{ lat: 35.440509, lng:  136.045418},
{ lat: 35.448200, lng:  136.055546},
{ lat: 35.459527, lng:  136.066532},
{ lat: 35.465679, lng:  136.077518},
{ lat: 35.456590, lng:  136.082497},
{ lat: 35.449039, lng:  136.087818},
{ lat: 35.449459, lng:  136.096230},
{ lat: 35.455891, lng:  136.103439},
{ lat: 35.464001, lng:  136.106358},
{ lat: 35.474906, lng:  136.110649},
{ lat: 35.480637, lng:  136.113567},
{ lat: 35.486089, lng:  136.118717},
{ lat: 35.482454, lng:  136.124039},
{ lat: 35.484551, lng:  136.131592},
{ lat: 35.475884, lng:  136.125755},
{ lat: 35.460226, lng:  136.125927},
{ lat: 35.455472, lng:  136.129704},
{ lat: 35.456730, lng:  136.143436},
{ lat: 35.443585, lng:  136.140347},
{ lat: 35.442466, lng:  136.149101},
{ lat: 35.451696, lng:  136.154423},
{ lat: 35.458688, lng:  136.157513},
{ lat: 35.462882, lng:  136.156483},
{ lat: 35.465958, lng:  136.148243},
{ lat: 35.470013, lng:  136.148930},
{ lat: 35.478121, lng:  136.152191},
{ lat: 35.486228, lng:  136.160603},
{ lat: 35.493636, lng:  136.159058},
{ lat: 35.505375, lng:  136.161289},
{ lat: 35.512222, lng:  136.161461},
{ lat: 35.511803, lng:  136.167812},
{ lat: 35.502720, lng:  136.170731},
{ lat: 35.498108, lng:  136.177082},
{ lat: 35.503279, lng:  136.184635},
{ lat: 35.494055, lng:  136.192188},
{ lat: 35.478400, lng:  136.190300},
{ lat: 35.464560, lng:  136.194420},
{ lat: 35.452231, lng:  136.199226},
{ lat: 35.447197, lng:  136.189957},
{ lat: 35.432092, lng:  136.198883},
{ lat: 35.413907, lng:  136.205063},
{ lat: 35.395717, lng:  136.218796},
{ lat: 35.386761, lng:  136.224632},
{ lat: 35.384242, lng:  136.248322},
{ lat: 35.374725, lng:  136.263084},
{ lat: 35.358207, lng:  136.279564},
{ lat: 35.333563, lng:  136.274757},
{ lat: 35.303589, lng:  136.262054},
{ lat: 35.275846, lng:  136.240425},
{ lat: 35.259868, lng:  136.217079},
{ lat: 35.242485, lng:  136.190643},
{ lat: 35.228744, lng:  136.162148},
{ lat: 35.216684, lng:  136.123695},
{ lat: 35.211355, lng:  136.110649},
{ lat: 35.199853, lng:  136.089706},
{ lat: 35.185264, lng:  136.069450},
{ lat: 35.168988, lng:  136.061897},
{ lat: 35.152147, lng:  136.063614},
{ lat: 35.141760, lng:  136.052971},
{ lat: 35.146813, lng:  136.027908},
{ lat: 35.138952, lng:  136.016579},
{ lat: 35.136145, lng:  136.000099},
{ lat: 35.139514, lng:  135.992546},
{ lat: 35.133056, lng:  135.982246},
{ lat: 35.118455, lng:  135.971260},
{ lat: 35.121263, lng:  135.952721},
{ lat: 35.106659, lng:  135.942421},
{ lat: 35.083906, lng:  135.943794},
{ lat: 35.066204, lng:  135.942764},
{ lat: 35.056369, lng:  135.931778},
{ lat: 35.044002, lng:  135.919418},
{ lat: 35.032477, lng:  135.911179},
{ lat: 35.018982, lng:  135.917702},
{ lat: 34.997048, lng:  135.915642},
{ lat: 34.984672, lng:  135.909462}
    ];

    const lakeEdgePoints = interpolatePoints(rawLakePoints, 4); // 4å€è£œé–“

  let imgLoaded = false;
    const biwakoElevation = 85.0;
    const lakeArea = 670000000;
    const volume = 20100000;
    const massTons = volume;
    let lineLayer;
    let poolLayer;
    const map = L.map('map').setView([35.2, 136.0], 9);

  // --- ã‚µãƒ³ãƒ—ãƒ«åº§æ¨™ï¼ˆè¦ç¾å ´ã«åˆã‚ã›ã¦ä¿®æ­£ï¼‰ ---
  const imageBounds = [
    [34.7500,135.7500000000], // å—è¥¿ (lat, lng)
    [35.75,136.5]  // åŒ—æ± (lat, lng)
  ];

const west = 135.75+.035;
const north = 35.75-0.055;//35.25;
const pxsize_x = 0.0001;     // Xæ–¹å‘ãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚º
const pxsize_y = -0.0001;    // Yæ–¹å‘ãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚ºï¼ˆé€šå¸¸ãƒã‚¤ãƒŠã‚¹ï¼ï¼‰
const width = 6750;
const height = 9000;
let map2D = [];  // 2Dé…åˆ—åŒ–  Ræˆåˆ†ã®ã¿

const east = west + pxsize_x * width;
const south = north + pxsize_y * height;  // æ³¨æ„ï¼šYæ–¹å‘ã¯ãƒã‚¤ãƒŠã‚¹ãªã®ã§ã€Œ+ã€
const imgArray = [];

let posjj=0;
let posjk=0;

map.on('moveend zoomend', updateContourLOD);
document.getElementById('altSlider').oninput = updateContourLOD;


// å¯è¦–ç¯„å›²ã‚’å¸¸ã«å›ºå®šã‚µã‚¤ã‚ºï¼ˆä¾‹ï¼š600x600ï¼‰ã«ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
const CANVAS_SIZE = 600;
function befstep()
{
  var level = parseInt(document.getElementById('altSlider').value);
  if(level>parseInt(document.getElementById('altSlider').min)){
    document.getElementById('altSlider').value=level-1;
    updateContourLOD();
  }
}
function nextstep()
{
 var level = parseInt(document.getElementById('altSlider').value);
  if(level<parseInt(document.getElementById('altSlider').max)){
    document.getElementById('altSlider').value=level+1;
    updateContourLOD();
  }
  
}
// ã‚°ãƒ­ãƒ¼ãƒãƒ«
let overlay = null;
// ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”Ÿæˆæ™‚ï¼ˆç­‰é«˜ç·šãƒ»ãƒã‚¹ã‚¯æç”»æ™‚ã®ãŸã³ã«ï¼‰
// overlayæç”»
function showOverlay(url, bounds) {
  if (overlay && map.hasLayer(overlay)) {
    map.removeLayer(overlay);
    overlay = null;
  }
  overlay = L.imageOverlay(url, bounds, {opacity:0.5});
  overlay.addTo(map);
}

// OFFæ™‚ã®å®Œå…¨æ¶ˆå»
function hideOverlay() {
   console.log("overlayæ¶ˆã—ã¾ã—ã‚‡ã†");
  if (overlay && map.hasLayer(overlay)) {
    map.removeLayer(overlay);
    overlay = null;
    console.log("overlayæ¶ˆã—ãŸï¼");
  }
}


function updateContourLOD() {
  // 1. åœ°å›³ã®ç¾åœ¨è¡¨ç¤ºç¯„å›²
  const bounds = map.getBounds();
  const nw = bounds.getNorthWest();
  const se = bounds.getSouthEast();

  // 2. åœ°ç†åº§æ¨™â†’ç”»åƒãƒ”ã‚¯ã‚»ãƒ«å¤‰æ›
  function latlngToImgXY(lat, lng) {
    const latMin = imageBounds[0][0], latMax = imageBounds[1][0];
    const lngMin = imageBounds[0][1], lngMax = imageBounds[1][1];
    const y = Math.round((latMax - lat) / (latMax - latMin) * img.naturalHeight);
    const x = Math.round((lng - lngMin) / (lngMax - lngMin) * img.naturalWidth);
    return {x, y};
  }
  const p1 = latlngToImgXY(nw.lat, nw.lng);
  const p2 = latlngToImgXY(se.lat, se.lng);
  const sx = Math.min(p1.x, p2.x), sy = Math.min(p1.y, p2.y);
  const sw = Math.abs(p1.x - p2.x), sh = Math.abs(p1.y - p2.y);

  // 3. å¿…ãšCANVAS_SIZEã§æç”»ï¼ˆé‡ãã—ãªã„ï¼ï¼‰
  const canvas = document.getElementById('contourCanvas');
  canvas.width = CANVAS_SIZE;
  canvas.height = CANVAS_SIZE;
  
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  if(!document.getElementById('sliderSwitch').checked)
    return;

if(!document.getElementById('sliderSwitch').checked) {
    hideOverlay();
    return;
  }
    // 4. drawImageã§ç¸®å°è²¼ä»˜ï¼ˆç­‰é«˜ç·šã®ç²¾åº¦ã¯ã»ã©ã»ã©ã§OKï¼‰
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // 5. é…åˆ—åŒ–
  let arr = [];
  let imgData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE).data;
  for (let y = 0; y < CANVAS_SIZE; y++) {
    arr[y] = [];
    for (let x = 0; x < CANVAS_SIZE; x++) {
      arr[y][x] = imgData[(y * CANVAS_SIZE + x) * 4];
    }
  }

  // 6. ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã§ç­‰é«˜ç·šæŠ½å‡º
  const level = parseInt(document.getElementById('altSlider').value);
  const contours = MarchingSquaresJS.isoLines(arr, level);
    document.getElementById('spnJS').textContent = "æ¨™é«˜ã€€ã€€"+level*10+"m ã®ç·šã‚’è¡¨ç¤º";

  // 7. ç­‰é«˜ç·šã‚’canvasã«æç”»
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.drawImage(img, sx, sy, sw, sh, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
  ctx.save();
  ctx.lineWidth = 1.2;
  ctx.strokeStyle = 'red';
  contours.forEach(line => {
    ctx.beginPath();
    line.forEach(([x, y], i) => i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y));
    ctx.stroke();
  });
  ctx.restore();
let iimgData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
let idata = iimgData.data;

for(let y=0; y<CANVAS_SIZE; y++) {
  for(let x=0; x<CANVAS_SIZE; x++) {
    const idx = (y * CANVAS_SIZE + x) * 4;
    const v = idata[idx]; // Rå€¤ãŒæ¨™é«˜
    if(v < level) {
      // æ°´è‰² (ä¾‹: R=120, G=180, B=255)
      idata[idx] = 120;
      idata[idx+1] = 180;
      idata[idx+2] = 255;
      idata[idx+3] = 200; // é€æ˜åº¦: 0ã€œ255ï¼ˆãŠå¥½ã¿ã§èª¿æ•´ï¼‰
    }
    // ãã‚Œä»¥å¤–ã¯ãã®ã¾ã¾
  }
}
 
ctx.putImageData(iimgData, 0, 0); 
    // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
/*   setTimeout(()=>{
      if(overlay) map.removeLayer(overlay);
      overlay = L.imageOverlay(canvas.toDataURL('image/png'), bounds, {opacity:0.5}).addTo(map);
      isUpdating = false;
    }, 0);
*/ 
  if(!document.getElementById('sliderSwitch').checked) {
    hideOverlay();
    return;
  }
  // canvasã§æç”» â†’ overlayåŒ–
//  const canvas = document.getElementById('contourCanvas');
  // willReadFrequentlyæœ€é©åŒ–
  // ...canvasæç”»å‡¦ç†...
  const overlayUrl = canvas.toDataURL('image/png');
  showOverlay(overlayUrl, map.getBounds());
  //showOverlay(canvas.toDataURL('image/png'), bounds); 
/*
  // 8. ImageOverlayã§åœ°å›³ã«è¼‰ã›ã‚‹
  const overlayUrl = canvas.toDataURL('image/png');
  if(window.redOverlay) map.removeLayer(window.redOverlay);
  window.redOverlay = L.imageOverlay(overlayUrl, bounds, {opacity: 0.5}).addTo(map);
*/
}

function toggleInputGroup() {
  const group = document.getElementById('inputGroup');
  if(globalLat && globalLon) {

   // displayãŒnoneãªã‚‰blockã«ã€blockãªã‚‰noneã«åˆ‡ã‚Šæ›¿ãˆã‚‹
    if (group.style.display === 'none') {
      group.style.display = 'block';
    } else if (group.style.display === 'block') {
      group.style.display = 'none';
    } else{
      group.style.display = 'block';
    }
  }

}
    function interpolatePoints(points, divisions = 4) {
      const result = [];
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        for (let j = 0; j <= divisions; j++) {
          const t = j / divisions;
          result.push({
            lat: p1.lat * (1 - t) + p2.lat * t,
            lng: p1.lng * (1 - t) + p2.lng * t
          });
        }
      }
      return result;
    }
let markers = [];
function removemarkers(){
  markers.forEach(m => m.remove(map));
}
function addmarkers()
{
  markers.forEach(m => m.addTo(map));
}
let myChart = null;

let arr = null, imgWidth = 0, imgHeight = 0;
const img = new Image();
img.src = 'images/BIWAKOALL8.PNG';
//const targetW = 650, targetH = 900;
const imgcanvas = document.createElement('canvas');
const imgctx = imgcanvas.getContext('2d');

img.onload = function() {
    imgcanvas.width = img.width;
  imgcanvas.height = img.height;
  imgctx.drawImage(img, 0, 0);
  const imageData = imgctx.getImageData(0, 0, img.width, img.height).data;

  // 2Dé…åˆ—åŒ–
  for (let y = 0; y < img.height; y++) {
    let row = [];
    for (let x = 0; x < img.width; x++) {
      // ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ãªã‚‰Rã®ã¿ã§OK
      let i = (y * img.width + x) * 4;
      let val = imageData[i]; // Ræˆåˆ†ã®ã¿
      row.push(val);
    }
    map2D.push(row);
  }

/*  // ç¸®å°Canvasã«draw
  let tmp = document.createElement('canvas');
  tmp.width = targetW;
  tmp.height = targetH;
  let tctx = tmp.getContext('2d');
  tctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, targetW, targetH);

  // 2Dé…åˆ—åŒ–
  let arr = [];
  let imgData = tctx.getImageData(0, 0, targetW, targetH).data;
  for (let y = 0; y < targetH; y++) {
    arr[y] = [];
    for (let x = 0; x < targetW; x++) {
      arr[y][x] = imgData[(y * targetW + x) * 4]; // Rå€¤ã®ã¿
    }
  }

  // ç­‰é«˜ç·šæŠ½å‡ºï¼ˆMarchingSquaresJSï¼‰â†’æç”»
  drawContourLowRes(arr, targetW, targetH);
*/
};

function drawContourLowRes(arr, w, h) {
/*  const canvas = document.getElementById('contourCanvas');
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, w, h);

  const level = parseInt(document.getElementById('altSlider').value);
  const contours = MarchingSquaresJS.isoLines(arr, level);

  ctx.save();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'red';
  contours.forEach(line => {
    ctx.beginPath();
    line.forEach(([x, y], i) => i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y));
    ctx.stroke();
  });
  ctx.restore();
*/
}
/*-------------------------------------------------------------*/
// 0ï¼ˆå®Œå…¨é€æ˜ï¼‰ï½1ï¼ˆå®Œå…¨ä¸é€æ˜ï¼‰ã§æŒ‡å®š

//L.imageOverlay(img.src, imageBounds, {opacity: 0.5  }).addTo(map);
    L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
      maxZoom: 17,
      attribution: 'Â© OpenTopoMap (CC-BY-SA)'
    }).addTo(map);
 
   // CSVå–å¾—ã—ã¦ãƒ‘ãƒ¼ã‚¹ã—ã¦ãƒ”ãƒ³è¡¨ç¤º
    //fetch(CSV_URL)
    fetch(CSV_URL + "&ts=" + Date.now())
  .then(res => res.text())
  .then(csv => {
    // Papaparseã§CSVã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆè‡ªå‹•ã§ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚„æ”¹è¡Œã‚‚OKï¼‰
    const result = Papa.parse(csv, { header: true });
    const rows = result.data;
    rows.forEach(row => {
      let title = row['ã‚¿ã‚¤ãƒˆãƒ«'];
      let comment = row['ã‚³ãƒ¡ãƒ³ãƒˆ'] || '';
      let elev=row['æ¨™é«˜'] || '';
      const color = (row['è‰²'] || '').trim(); // è‰²
//      console.log('è‰²:', color, 'URL:', colorMap[color]);
 
const   icon = new L.Icon({
     iconUrl: colorMap[color],
  //iconUrl: 'images/marker-icon-red.png',
      shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
comment = comment.replace(/\r?\n/g, '<br>');
    const marker = L.marker(
      [parseFloat(row['ç·¯åº¦']), parseFloat(row['çµŒåº¦'])], // å¿…ãšé…åˆ—ã§ï¼
      { icon: icon } // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³æŒ‡å®š
    ).addTo(map)        .bindPopup(`<b>${title} ${elev}m </b><br>${comment}`);
  markers.push(marker);
  
   });
  });
// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å®£è¨€
let globalLat = null;
let globalLon = null;
let globalElev = null;
    function openGoogleMap(lat, lng) {
     if(globalLat && globalLon) {
       const url = `https://www.google.com/maps?q=${globalLat},${globalLon}`;
       window.open(url, '_blank');
     } else {
       alert("åœ°å›³ä¸Šã®å ´æ‰€ã‚’é¸ã‚“ã§ãã ã•ã„ï¼");
     }
    }
  function openGsiMap(lat, lng, zoom=16) {
    if(globalLat && globalLon) {
      const url = `https://maps.gsi.go.jp/#${zoom}/${globalLat}/${globalLon}`;
      window.open(url, '_blank');
    } else {
      alert("åœ°å›³ä¸Šã®å ´æ‰€ã‚’é¸ã‚“ã§ãã ã•ã„ï¼");
    }

  }

   function toRad(deg) {
      return deg * Math.PI / 180;
    }

    function calcDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

// æ–°ï¼šé–¢æ•°ã¨ã—ã¦å®šç¾©
function normalClickHandler(e) {
  const lat = e.latlng.lat;
  const lon = e.latlng.lng;
  document.getElementById('coords').textContent = `ç·¯åº¦ãƒ»çµŒåº¦ï¼š${lat.toFixed(6)}, ${lon.toFixed(6)}ã€€ã€€ã€€`;
  globalLat = e.latlng.lat;
  globalLon = e.latlng.lng;

  fetch(`https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php?lon=${lon}&lat=${lat}&outtype=JSON`)
    .then(res => res.json())
    .then(data => {
      const elev = parseFloat(data.elevation);
      globalElev = elev;
      document.getElementById('elevation').textContent = `ä¸Šæ± æ¨™é«˜ï¼š${elev.toFixed(1)} m`;

      const drop = elev - biwakoElevation;
      document.getElementById('drop').textContent = `æœ‰åŠ¹è½å·®ï¼š${drop.toFixed(1)} m`;

      const energyJoules = massTons * 1000 * 9.8 * drop;
      const energyGWh = energyJoules / 3.6e12;
      document.getElementById('energy').textContent = `ä½ç½®ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼š${energyGWh.toFixed(3)} GWh`;

      const suiisa = (volume * 1000) / lakeArea;
      document.getElementById('suii').textContent = `çµç¶æ¹–æ°´ä½å·®ï¼š${suiisa.toFixed(3)} mm`;
//---20250527
      const bottomElevation = 83;

//const h = elevation - bottomElevation;
const h=drop;
if (h <= 0) return;

const area = volume / h;
const radius = Math.sqrt(area / Math.PI)+50; // å˜ä½ï¼šm

      let minDist = Infinity;
      let nearestPoint = null;
      lakeEdgePoints.forEach(pt => {
        const d = calcDistance(lat, lon, pt.lat, pt.lng);
        if (d < minDist) {
          minDist = d;
          nearestPoint = pt;
        }
      });
      document.getElementById('distance').textContent = `æœ€çŸ­è·é›¢ï¼š${minDist.toFixed(2)} km`;

      if (lineLayer) map.removeLayer(lineLayer);
      const nearestLatLng = L.latLng(nearestPoint.lat, nearestPoint.lng);
      lineLayer = L.polyline([e.latlng, nearestLatLng], { color: 'blue' }).addTo(map);

      if (poolLayer) map.removeLayer(poolLayer);
      poolLayer = L.circle([lat, lon], {
        radius: radius, //200,
        color: '#2196f3',
        fillColor: '#bbdefb',
        fillOpacity: 0.5
      }).addTo(map).bindPopup(`ä»®æƒ³ãƒ€ãƒ ãƒ—ãƒ¼ãƒ«<br>åŠå¾„150m`);

      document.getElementById('lakeLevelBar').style.height = Math.min(100, suiisa) + '%';
      document.getElementById('lakeValueLabel').textContent = suiisa.toFixed(1) + ' mm';

      const energyBar = Math.min(100, (energyGWh / 100) * 100);
      document.getElementById('energyLevelBar').style.height = energyBar + '%';
      document.getElementById('energyValueLabel').textContent = energyGWh.toFixed(2) + ' GWh';
    })
    .catch(() => {
      document.getElementById('elevation').textContent = `æ¨™é«˜å–å¾—å¤±æ•—`;
    });
}
map.on('click', normalClickHandler);
    var openedWindow;
    // Googleãƒ•ã‚©ãƒ¼ãƒ ã®URLï¼ˆURLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å„é …ç›®ã‚’æ¸¡ã™GETé€ä¿¡ä¾‹ï¼‰
    function submitForm() {
      const title = encodeURIComponent(document.getElementById('title').value);
      const comment = encodeURIComponent(document.getElementById('comment').value);
      const color = encodeURIComponent(document.querySelector('input[name="color"]:checked').value);
const rawTitle = document.getElementById('title').value;
const rawComment = document.getElementById('comment').value;
      if (rawTitle == null || rawTitle === '' || rawComment == null || rawComment === ''){
        alert("è¨­å®šãŒã‚ã‚Šã¾ã›ã‚“ \nã‚¿ã‚¤ãƒˆãƒ«ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); 
        return;
      }
  //    const elev=encodeURIComponent(document.getElementById('elevation').value);
      // ã“ã“ã¯Googleãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰IDã«æ›¸ãæ›ãˆï¼
        // const url = `https://docs.google.com/forms/d/e/1FAIpQLSfFurEII3ojMqlp5Rgc0KinkQ5gkmc9R6ijBzNqv8kvHumjyw/formResponse?entry.138516219=${title}&entry.514491795=${comment}&entry.1688590365=${color}&entry.1150820012=${lat}&entry.1539234844=${lng}`;
    const url = `https://docs.google.com/forms/d/e/1FAIpQLSfFurEII3ojMqlp5Rgc0KinkQ5gkmc9R6ijBzNqv8kvHumjyw/formResponse?entry.138516219=${title}&entry.1539234844=${comment}&entry.1688590365=${color}&entry.1613901500=${globalElev}&entry.514491795=${globalLat}&entry.1150820012=${globalLon}`;
      openedWindow=window.open(url, '_blank');
    //  window.close(openedWindow);
    const ccolor = document.querySelector('input[name="color"]:checked').value;
 //     console.log('BTN  è‰²:', ccolor, 'URL:', colorMap[ccolor]);
    const   icon = new L.Icon({
      iconUrl: colorMap[ccolor],
  //iconUrl: 'images/marker-icon-red.png',
      shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
      var ccomment = document.getElementById('comment').value;
      ccomment = ccomment.replace(/\r?\n/g, '<br>');
      const marker = L.marker(
      [globalLat, globalLon], // å¿…ãšé…åˆ—ã§ï¼
      { icon: icon } // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³æŒ‡å®š
      ).addTo(map)        .bindPopup(`<b>${rawTitle} ${globalElev}m </b><br>${ccomment}`);
      markers.push(marker);
    }
 // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ç›´æ¥ã‚¢ãƒ­ãƒ¼é–¢æ•°ã§æ›¸ã

// ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²
document.getElementById('pinSwitch').addEventListener('change', function(){
  // ãƒ”ãƒ³è¡¨ç¤ºã®ON/OFFåˆ‡æ›¿
 if(this.checked){
  markers.forEach(m => m.addTo(map));
 }else{
  markers.forEach(m => m.remove(map));
 }
});
document.getElementById('pinGamenSwitch').addEventListener('change', function(){
//  toggleInputGroup();
  const group = document.getElementById('inputGroup');
  if(globalLat && globalLon) {

   // displayãŒnoneãªã‚‰blockã«ã€blockãªã‚‰noneã«åˆ‡ã‚Šæ›¿ãˆã‚‹
    if (this.checked) {
      group.style.display = 'block';
    } else{
      group.style.display = 'none';
    }
  }else if(this.checked){
    alert("åœ°å›³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦åœ°ç‚¹ã‚’æ±ºã‚ã¦ã­");
    this.checked=0;
  }
});
document.getElementById('sliderSwitch').addEventListener('change', function(){
  // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼‹æ°´æ²¡ãƒã‚¹ã‚¯ã®ON/OFF
  toggleSliderAndFlood(this.checked);
});
document.getElementById('damSwitch').addEventListener('change', function(){
  // ãƒ€ãƒ å»ºè¨­ãƒ¢ãƒ¼ãƒ‰ï¼ˆå ¤ä½“æŒ‡å®šãƒ»flood fillãªã©ï¼‰
  toggleDamMode(this.checked);
});

// ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
function togglePins(isOn) {
  // ä¾‹: ãƒ”ãƒ³ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º/éè¡¨ç¤º
  if(isOn) { pinLayer.addTo(map); } else { map.removeLayer(pinLayer); }
}
function toggleSliderAndFlood(isOn) {
  document.getElementById('altSlider').style.display = isOn ? '' : 'none';
  document.getElementById('nextpb').style.display = isOn ? '' : 'none';
  document.getElementById('befpb').style.display = isOn ? '' : 'none';
  document.getElementById('toukousen').style.display = isOn ? '' : 'none';
  document.getElementById('spnJS').style.display = isOn ? '' : 'none';

  if (overlay) {
   // â€¦UIåˆ‡ã‚Šæ›¿ãˆçœç•¥
    if (!isOn) {
      hideOverlay();
      return;
    }
    // isOnæ™‚ã¯ç­‰é«˜ç·šå‡¦ç†
    updateContourLOD();
  }
}
let damFirstPoint = null;
let damTempLine = null;
let damLines = [];
function toggleDamMode(isOn) {
  // ä¾‹: ãƒ€ãƒ å ¤ä½“ã‚¯ãƒªãƒƒã‚¯å—ä»˜ãƒ»å† æ°´ç¯„å›²å†æç”»ãªã©
  const mapDiv = document.getElementById('map');
  damMode=isOn;
  document.getElementById('DAMclearPB').style.display = isOn ? '' : 'none';
  document.getElementById('doDAMPB').style.display = isOn ? '' : 'none';

  if(isOn) {
    if (poolLayer) map.removeLayer(poolLayer);    mapDiv.classList.add('crosshair');
    if (lineLayer) map.removeLayer(lineLayer);
    mapDiv.classList.remove('grab');
    // ãƒ€ãƒ å»ºè¨­ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ON
    enableDamDrawing();
  } else {
    mapDiv.classList.remove('crosshair');
    mapDiv.classList.add('grab');
    // ãƒ€ãƒ å»ºè¨­ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³OFF
    disableDamDrawing();
  }
}
    let clickPoints = [];
    let lines = [];
//    let lineLayers = [];
let points = [];
//let tempLine = null;
let polyline = null;
let polygon = null;
const closeThreshold = 10; // ãƒ”ã‚¯ã‚»ãƒ«è·é›¢ã§åˆ¤å®š

// ãƒ€ãƒ ã‚¯ãƒªãƒƒã‚¯ç”¨
function damClickHandler(e) {
 let latlng = e.latlng;


  // æœ€åˆã®ç‚¹ or ç¶™ç¶š
  clickPoints.push(latlng);
 if (!firstPoint) {
    firstPoint = e.latlng;
    map.on('mousemove', damMoveHandler);
  } else {
  }

  // Polylineã§å‹•çš„ã«ç·šã‚’æç”»
  if (polyline) map.removeLayer(polyline);
  polyline = L.polyline(clickPoints, {color: 'blue', weight: 3}).addTo(map);

  // é–‰ã˜åˆ¤å®šï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ãŒè¿‘ã‘ã‚Œã°PolygonåŒ–ï¼‰
  if (clickPoints.length > 2) {
    let start = map.latLngToContainerPoint(clickPoints[0]);
    let end = map.latLngToContainerPoint(latlng);
    if (start.distanceTo(end) < closeThreshold) {
      if (polygon) map.removeLayer(polygon);
      polygon = L.polygon(clickPoints, {color: 'red', fillOpacity: 0.3}).addTo(map);

      // å®Œäº†å¾Œã€åˆæœŸåŒ–ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
     // clickPoints = [];
      if (polyline) map.removeLayer(polyline);
      polyline=null;
      firstPoint = e.latlng;
      map.on('mousemove', damMoveHandler);
      firstPoint=null;
      map.off('mousemove', damMoveHandler);
    }
  }
 // ç¢ºå®šå¾Œã€ä»®ç·šã¯å¿…ãšæ¶ˆã™
  if (tempLine) {
    map.removeLayer(tempLine);
    tempLine = null;
  }
  firstPoint = null; // ãƒªã‚»ãƒƒãƒˆ

}

function clearLines() { 
    if(polygon){
      map.removeLayer(polygon);
      polygon=[];
    }
    if(tempLine){
      map.removeLayer(tempLine);
      polyline=[];
    }
    if(polyline){
      map.removeLayer(polyline);
      polyline=[];
    }
                  // åœ°å›³ä¸Šã®ç·šåˆ†ã‚’ã™ã¹ã¦å‰Šé™¤
       //   clickPoints.forEach(clickPoints => map.removeLayer(clickPoints));
      clickPoints=[];
    lines = [];
      clickPoints = [];
      firstPoint=null;
if (tempLine) {
    map.removeLayer(tempLine);
    tempLine = null;
  }
//      document.getElementById('log').textContent = 'ãƒ€ãƒ ç·šåˆ†ãƒªã‚¹ãƒˆ:\n[]';
}

function damMoveHandler(e) {
  if (clickPoints.length === 0) return;
  let tempPoints = clickPoints.slice();
  tempPoints.push(e.latlng); // ãƒã‚¦ã‚¹ãƒã‚¤ãƒ³ã‚¿ã‚’ä»®ã®æ¬¡ç‚¹ã¨ã™ã‚‹

  // å‰ã®ä»®ç·šã‚’æ¶ˆã—ã¦ã‹ã‚‰å†æç”»
  if (tempLine) map.removeLayer(tempLine);
  tempLine = L.polyline(tempPoints, {color: 'yellow', dashArray: '4', weight: 2}).addTo(map);
/*
 if (points.length === 0) return;

  // ãƒã‚¦ã‚¹ãƒã‚¤ãƒ³ã‚¿ï¼‹ç¢ºå®šç‚¹ã‚’åˆã‚ã›ã¦ã€Œä¸€æœ¬ã®ä»®ãƒ©ã‚¤ãƒ³ã€ã‚’æ§‹æˆ
  let displayPoints = points.slice();
  let mousePt = [e.latlng.lat, e.latlng.lng];
  let startPt = map.latLngToContainerPoint(points[0]);
  let curPt = map.latLngToContainerPoint(mousePt);
  let isClose = startPt.distanceTo(curPt) < closeThreshold;

  if (isClose) {
    displayPoints.push(points[0]); // å§‹ç‚¹ã«å¸ç€ã—ã¦é–‰ã˜ã‚‹
  } else {
    displayPoints.push(mousePt);
  }

  // å‰ã®ä»®ç·šã‚’æ¶ˆã—ã¦ã‹ã‚‰å†æç”»
  if (tempLine) map.removeLayer(tempLine);
  tempLine = L.polyline(displayPoints, {
    color: isClose ? 'red' : 'blue',
    dashArray: '4',
    weight: 2
  }).addTo(map);
*/
/*  if (damFirstPoint) {
    if (damTempLine) map.removeLayer(damTempLine);
    damTempLine = L.polyline([damFirstPoint, e.latlng], { color: 'orange', weight: 2, dashArray: '5,5' }).addTo(map);
  }
*/
}

// ä¾‹ï¼šãƒ€ãƒ å»ºè¨­ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æœ‰åŠ¹åŒ–
function enableDamDrawing() {
  map.off('click', normalClickHandler); // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯ã‚’å¤–ã™
  map.on('click', damClickHandler);     // ãƒ€ãƒ å»ºè¨­ã‚¯ãƒªãƒƒã‚¯ã‚’æœ‰åŠ¹åŒ–
}
function disableDamDrawing() {
  map.off('click', damClickHandler);    // ãƒ€ãƒ å»ºè¨­ã‚¯ãƒªãƒƒã‚¯ã‚’å¤–ã™
  map.on('click', normalClickHandler);  // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯ã‚’æœ‰åŠ¹åŒ–
  if (damTempLine) {
    map.removeLayer(damTempLine);
    damTempLine = null;
  }
  damFirstPoint = null;
  map.off('mousemove', damMoveHandler);
}
let tempLine = null;
let firstPoint = null;

function drawTempLine(e) {
  if (!firstPoint) return;

  // å‰ã®ä»®ç·šã‚’æ¶ˆã™ï¼ˆã“ã“ãŒè‚å¿ƒï¼ï¼‰
  if (tempLine) {
    map.removeLayer(tempLine);
    tempLine = null;
  }

  // æ–°ã—ã„ä»®ç·šã‚’æç”»
  tempLine = L.polyline([firstPoint, e.latlng], {
    color: 'blue',
    weight: 2,
    dashArray: '5,5'
  }).addTo(map);
}

/*
// ä¾‹: ãƒ€ãƒ å»ºè¨­ãƒ¢ãƒ¼ãƒ‰ã§
map.on('mousemove', function(e) {
  drawTempLine(e);
});

// ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ç¢ºå®š
map.on('click', function(e) {
  if (!firstPoint) {
    firstPoint = e.latlng;
    return;
  }

  // ç·šåˆ†ç¢ºå®šï¼ˆorå¤šè§’å½¢ã®ç‚¹è¿½åŠ ãªã©ï¼‰
  // ...çœç•¥...

  // ç¢ºå®šå¾Œã€ä»®ç·šã¯å¿…ãšæ¶ˆã™
  if (tempLine) {
    map.removeLayer(tempLine);
    tempLine = null;
  }
  firstPoint = null; // ãƒªã‚»ãƒƒãƒˆ
});
*/
/*
ãŠã¾ã‘ï¼šPolygonç‰ˆï¼ˆå¤–å‘¨å…¨éƒ¨ï¼‰
for(let i = 0; i < polyPoints.length; i++) {
  let j = (i + 1) % polyPoints.length;
  markDamLineAs127(
    polyPoints[i].lat, polyPoints[i].lng,
    polyPoints[j].lat, polyPoints[j].lng,
    map2D, waterVal
  );
}
  
 // 1. åœ°å›³ã®ç¾åœ¨è¡¨ç¤ºç¯„å›²
  const bounds = map.getBounds();
  const nw = bounds.getNorthWest();
  const se = bounds.getSouthEast();

  // 2. åœ°ç†åº§æ¨™â†’ç”»åƒãƒ”ã‚¯ã‚»ãƒ«å¤‰æ›
  function latlngToImgXY(lat, lng) {
    const latMin = imageBounds[0][0], latMax = imageBounds[1][0];
    const lngMin = imageBounds[0][1], lngMax = imageBounds[1][1];
    const y = Math.round((latMax - lat) / (latMax - latMin) * img.naturalHeight);
    const x = Math.round((lng - lngMin) / (lngMax - lngMin) * img.naturalWidth);
    return {x, y};
  }
  const p1 = latlngToImgXY(nw.lat, nw.lng);
  const p2 = latlngToImgXY(se.lat, se.lng);
  const sx = Math.min(p1.x, p2.x), sy = Math.min(p1.y, p2.y);
  const sw = Math.abs(p1.x - p2.x), sh = Math.abs(p1.y - p2.y);

const img = new Image();
img.src = 'images/BIWAKOALL8.PNG';
*/


//1. ç·šåˆ†ã®ä¸¡ç«¯ï¼ˆç·¯åº¦çµŒåº¦ï¼‰ã‚’2Dãƒãƒƒãƒ—åº§æ¨™(x, y)ã«å¤‰æ›
function latLngToXY(lat, lng, latMin, latMax, lngMin, lngMax, width, height) {
  const x = Math.round((lng - lngMin) / (lngMax - lngMin) * (width - 1));
  const y = Math.round((latMax - lat) / (latMax - latMin) * (height - 1));
  return [x, y];
}
// 2. Bresenhamã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ç·šåˆ†ä¸Šã®ã‚»ãƒ«ã‚’ã™ã¹ã¦åˆ—æŒ™
function bresenhamLine(x0, y0, x1, y1) {
  const points = [];
  x0 = Math.round(x0); y0 = Math.round(y0); // å°æ•°ãªã‚‰æ•´æ•°åŒ–
  x1 = Math.round(x1); y1 = Math.round(y1);

  const dx = Math.abs(x1 - x0);
  const dy = Math.abs(y1 - y0);
  const sx = (x0 < x1) ? 1 : -1;
  const sy = (y0 < y1) ? 1 : -1;
  let err = dx - dy;
x0 = Math.max(0, Math.min(Math.round(x0), width-1));
y0 = Math.max(0, Math.min(Math.round(y0), height-1));
x1 = Math.max(0, Math.min(Math.round(x1), width-1));
y1 = Math.max(0, Math.min(Math.round(y1), height-1));

 let step = 0, maxStep = Math.max(width, height)*2;
while (true) {
  points.push([x0, y0]);
  if (x0 === x1 && y0 === y1) break;
  const e2 = 2 * err;
  if (e2 > -dy) { err -= dy; x0 += sx; }
  if (e2 <  dx) { err += dx; y0 += sy; }
  if (++step > maxStep) break; // éå¸¸æ™‚ã®å®‰å…¨è£…ç½®
}
  return points;
}
/*function bresenhamLine(x0, y0, x1, y1) {
  const points = [];
  let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  let sx = (x0 < x1) ? 1 : -1;
  let sy = (y0 < y1) ? 1 : -1;
  let err = dx - dy;

  while(true) {
    points.push([x0, y0]);
    if ((x0 === x1) && (y0 === y1)) break;
    let e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x0 += sx; }
    if (e2 < dx)  { err += dx; y0 += sy; }
  }
  return points;
}*/
//3. å„ã‚»ãƒ«ã«ã¤ã„ã¦ã€Œæ°´ã‚»ãƒ«ï¼ˆä¾‹ãˆã°å€¤1ï¼‰ã€ãªã‚‰-127ï¼ˆãƒ€ãƒ ã‚»ãƒ«ï¼‰ã«ç½®æ›
function markDamLineAs127(lat1, lng1, lat2, lng2, map2D, waterVal = 1, damVal = -127,
                          latMin, latMax, lngMin, lngMax, width, height) {
  // 1. ç·¯åº¦çµŒåº¦ â†’ ç”»åƒåº§æ¨™
  const [x1, y1] = latLngToXY(lat1, lng1, latMin, latMax, lngMin, lngMax, width, height);
  const [x2, y2] = latLngToXY(lat2, lng2, latMin, latMax, lngMin, lngMax, width, height);

  // 2. ç·šä¸Šã®ã‚»ãƒ«åˆ—æŒ™
  const linePixels = bresenhamLine(x1, y1, x2, y2);

  // 3. æ°´ã‚»ãƒ«ãªã‚‰ãƒ€ãƒ ã‚»ãƒ«ã«
  for (const [x, y] of linePixels) {
    if (x < 0 || x >= width || y < 0 || y >= height) continue; // ç¯„å›²å¤–ã¯ã‚¹ã‚­ãƒƒãƒ—
    if (map2D[y][x] === waterVal) {
      map2D[y][x] = damVal;
    }
  }
}
//4. Polygonã®å ´åˆã¯å¤–å‘¨ã™ã¹ã¦ã®ç·šåˆ†ã§ç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã™
function markPolygonEdgesAsDam(polyPoints, map2D, waterVal, damVal){//, ...geoParams) {
  for(let i = 0; i < polyPoints.length; i++) {
    let j = (i + 1) % polyPoints.length;
    markDamLineAs127(
      polyPoints[i][0], polyPoints[i][1],
      polyPoints[j][0], polyPoints[j][1]//,      map2D, waterVal, damVal, ...geoParams
    );
  }
}
//----------------------------------------------------------
//1. Polygonå†…åˆ¤å®šï¼ˆç‚¹ãŒPolygonå†…ã‹ã©ã†ã‹ï¼‰
// point: [lat, lng], polygon: array of [lat, lng]
//
//2. Polylineä¸Šï¼ˆç·šåˆ†ä¸Šï¼‰åˆ¤å®š
// point: [lat, lng], segA, segB: [lat, lng]
function isPointOnLineSegment(point, segA, segB, tolerance = 1e-5) {
  function dist(a, b) {
    return Math.sqrt(Math.pow(a[0]-b[0],2) + Math.pow(a[1]-b[1],2));
  }
  const d1 = dist(point, segA);
  const d2 = dist(point, segB);
  const d = dist(segA, segB);
  return Math.abs((d1 + d2) - d) < tolerance;
}
var damH,damL,koA,KoV,koL;

// --- 1. ç·¯åº¦çµŒåº¦â†’ç”»åƒåº§æ¨™(x, y)ã«å¤‰æ› ---
function latLngToXY(lat, lng, latMin, latMax, lngMin, lngMax, width, height) {
  const x = Math.round((lng - lngMin) / (lngMax - lngMin) * (width - 1));
  const y = Math.round((latMax - lat) / (latMax - latMin) * (height - 1));
  return [x, y];
}
function XY2latlng(x, y, latMin, latMax, lngMin, lngMax, width, height) {
  const lng = lngMin + (x / (width - 1)) * (lngMax - lngMin);
  const lat = latMax - (y / (height - 1)) * (latMax - latMin);
  return [lat, lng];
}

// å…¨é ‚ç‚¹ã‚’ç”»åƒåº§æ¨™ã¸
const polyXY = polygon.map (([lat, lng]) =>
  latLngToXY(lat, lng, latMin, latMax, lngMin, lngMax, width, height)
);

// --- 2. å¤–æ¥çŸ©å½¢ã‚’æ±‚ã‚ã‚‹ ---
const xs = polyXY.map2D (p => p[0]);
const ys = polyXY.map2D (p => p[1]);
const minX = Math.floor(Math.min(...xs));
const maxX = Math.ceil(Math.max(...xs));
const minY = Math.floor(Math.min(...ys));
const maxY = Math.ceil(Math.max(...ys));

// --- 3. ç‚¹ãŒPolygonå†…ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°ï¼ˆeven-odd/ray-castingæ³•ï¼‰---
/*function isPointInPolygon(x, y, polyXY) {
  let inside = false;
  for (let i = 0, j = polyXY.length - 1; i < polyXY.length; j = i++) {
    let xi = polyXY[i][0], yi = polyXY[i][1];
    let xj = polyXY[j][0], yj = polyXY[j][1];
    let intersect =
      ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}*/
function isPointInPolygon(x, y, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0], yi = polygon[i][1];
    const xj = polygon[j][0], yj = polygon[j][1];
    const intersect =
      ((yi > y) !== (yj > y)) &&
      (x < ((xj - xi) * (y - yi)) / (yj - yi + 0.00001) + xi); // +0.00001ã§0å‰²é˜²æ­¢
    if (intersect) inside = !inside;
  }
  return inside;
}
// 2Dé…åˆ—å…¨ä½“ã«é©ç”¨ã™ã‚‹ãƒ•ãƒ­ãƒ¼
//const width = img.width;     // ä¾‹: 6750
//const height = img.height;   // ä¾‹: 9000

function doDAM(){
const latMin = 34.7500;  // å—ç«¯
const latMax = 35.7500;  // åŒ—ç«¯
const lngMin = 135.7500; // è¥¿ç«¯
const lngMax = 136.5000; // æ±ç«¯
 if (clickPoints.length > 2) {
  let start = clickPoints[0];
  let end = clickPoints[clickPoints.length-1];
  // ã—ãã„å€¤è·é›¢ä»¥å†…ãªã‚‰å¼·åˆ¶çš„ã«å§‹ç‚¹ã‚’è¿½åŠ ã—ã¦é–‰ã˜ã‚‹
  if (0 && distance(start, end) > someThreshold) {
    clickPoints.push(start);
  } else {
    clickPoints[clickPoints.length-1] = start; // ä¸Šæ›¸ãã§ã‚‚OK
  }
 }        document.getElementById('log').textContent =
          'ãƒ€ãƒ ç·šåˆ†ãƒªã‚¹ãƒˆ:\n' + JSON.stringify(clickPoints, null, 2);
const clabels = [];
const cdata = [];
 let slidvalue= document.getElementById('altSlider').value;
  damH=0; damL=0; koA=0; koV=0,koL=0;
  let i=0,j=0; 
  for(i = 0; i < clickPoints.length - 1; i++) {
  const ptA = [clickPoints[i].lat, clickPoints[i].lng];
  const ptB = [clickPoints[i+1].lat, clickPoints[i+1].lng];

  // 1. ç·¯åº¦çµŒåº¦ â†’ ç”»åƒXYåº§æ¨™
  const [x1, y1] = latLngToXY(ptA[0], ptA[1], latMin, latMax, lngMin, lngMax, img.width, img.height);
  const [x2, y2] = latLngToXY(ptB[0], ptB[1], latMin, latMax, lngMin, lngMax, img.width, img.height);

  // 2. ç·šåˆ†ã‚»ãƒ«ã®æŠ½å‡ºï¼ˆBresenhamæ³•ï¼‰
  const linePixels = bresenhamLine(x1, y1, x2, y2);
  const level = parseInt(document.getElementById('altSlider').value);
// 3. å„ã‚»ãƒ«ã«ã¤ã„ã¦map2Dã‚’ãƒ€ãƒ å€¤ï¼ˆä¾‹: -127ï¼‰ã«
  for (const [x, y] of linePixels) {
    if (x < 0 || x >= img.width || y < 0 || y >= img.height) continue; // ç¯„å›²å¤–ã‚¬ãƒ¼ãƒ‰
    //    console.log('x:', x, 'y:', y);
    if (isNaN(x) || isNaN(y)) {
      console.error('NaNæ¤œå‡º', x, y);
  // return; // ã“ã“ã§æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ãªã©å®‰å…¨è£…ç½®
    }
    if(i==0){
      clabels.push(j*10);   // Xè»¸ç”¨
      cdata.push(map2D[y][x]*10);    // Yè»¸ç”¨ 10m
      j++;
    }
    if(map2D[y][x] <= slidvalue){
      damL+=1;
      if (damH===0 || damH>map2D[y][x] ){
        damH=map2D[y][x];         //ãƒ€ãƒ 
      }
      map2D[y][x] = 0x81;         //ãƒ€ãƒ 
    }
  }
// ã“ã‚Œã‚’Chart.jsã®labels, dataã¨ã—ã¦åˆ©ç”¨
}
posjj=j;

for(i=j; i < j + 10; i++){
     clabels.push(i*10);   // Xè»¸ç”¨
      cdata.push(85);    // Yè»¸ç”¨ 10m

} 
posjk=j;
//  console.log(clabels); // [0, 10, 20, 30]
//  console.log(cdata);   // [532, 531, 528, 525]

const waterLevel = slidvalue*10; // ä¾‹ï¼šãƒ€ãƒ æ°´ä½

const mountain = cdata.map(h => h > waterLevel ? h : null);
const lake     = cdata.map(h => h <= waterLevel && h !== 85 ? h : null);
const lakebiwa     = cdata.map(h => h <= 85 ? h : null);
//const lake = data.map(h => (h <= waterLevel || h === 85) ? h : null); // ã³ã‚æ¹–åŒºé–“ã‚‚å«ã‚ã‚‹
//const mountain = data.map(h => (h > waterLevel && h !== 85) ? h : null); // ã³ã‚æ¹–åŒºé–“ã¯null

//const cctx = document.getElementById('profileChart').getContext('2d');
const ccdata = {
  title: "ãƒ€ãƒ å®Œæˆæ–­é¢å›³",
  labels: clabels, // è·é›¢
  datasets: [
    {
      label: "å±±",
      type: "bar",
      data: mountain,
      backgroundColor: "green",
      borderColor: "green",
 //     borderWidth: 1,
      barPercentage: 1.0,
      categoryPercentage: 1.0
      
    },
    {
      label: "ãƒ€ãƒ æ¹–",
      type: "line",
      data: lake,
      borderColor: "deepskyblue",
      backgroundColor: "skyblue",
      fill: { target: { value: waterLevel } }
    },
    {
      label: "ã³ã‚æ¹–",
       type: "line",
      backgroundColor: "skyblue",
    //  borderColor: "white",
          data: lakebiwa,
      barPercentage: 1.0,         // æœ€å¤§å¹…ã«
      categoryPercentage: 1.0 ,    // éš™é–“ã‚¼ãƒ­
       fill: { target: { value: 0 } }
     }
  ]

};

const config = {
  type: "bar", // æœ€åˆã«barã‚’æŒ‡å®šï¼ˆlineã§ã‚‚OKã€datasetså„ªå…ˆï¼‰
  data: ccdata,
  options: {
    scales: {
      x: { title: { display: true, text: "ãƒ€ãƒ ã®æ–­é¢å›³ã€€ã€€è·é›¢ï¼ˆmï¼‰",font: { size: 28, }  } },
      y: { title: { display: true, text: "æ¨™é«˜ï¼ˆmï¼‰"} }
    },
  plugins: {
    annotation: {
      annotations: {
        damLakeLevel: {
          type: 'line',
          yMin: waterLevel, // ä¾‹: 500
          yMax: waterLevel,
          borderColor: 'blue',
          borderWidth: 2,
          label: {
            content: 'ãƒ€ãƒ æ¹–æ°´ä½ '+String(waterLevel)+'m',
            enabled: true,
              display: true,
            position: "end"
          }
        },
        biwakoLevel: {
          type: 'line',
          yMin: 85, // ä¾‹: 85
          yMax: 85,
          borderColor: 'deepskyblue',
          borderWidth: 2,
          label: {
            content: 'ã³ã‚æ¹–æ°´ä½ '+String(85)+'m',
            enabled: true,
              display: true,
            position: "start"
          }
        },
    /*    dropArrow: {
          type: 'box',
          xMin: clabels[posjj]-20, // ä¾‹: ã³ã‚æ¹–åŒºé–“é–‹å§‹ã®è·é›¢
          xMax: clabels[posjk]-20,    // ä¾‹: ã³ã‚æ¹–åŒºé–“çµ‚äº†ã®è·é›¢
          yMin: lakebiwa,
          yMax: lake,
          backgroundColor: 'rgba(255,0,0,0.08)',
          borderWidth: 0,
          label: {
            content: `è½å·®: ${waterLevel - 85} m`,
            enabled: true,
              display: true,
            position: "center"
          }
        },
    */     dropLabel: {
    type: 'label',
    xValue: posjj-10, // ä¾‹: 5
    yValue: (waterLevel + 85) / 2, // ä¸­å¤®
    content: [`è½å·®`, `${waterLevel - 85} m`],
    color: 'red',
           position: "right",
     font: { size: 16, weight: 'bold' },
    backgroundColor: 'rgba(255,255,255,0.9)'
  }
      }
    }
  }
}
}


if (myChart) {
  myChart.destroy();  // ã™ã§ã«ã‚°ãƒ©ãƒ•ãŒã‚ã‚Œã°ç ´æ£„
}
myChart = new Chart(document.getElementById("profileChart"), config);


const polyXY = clickPoints.map(({lat, lng}) =>
  latLngToXY(lat, lng, latMin, latMax, lngMin, lngMax, img.width, img.height)
);
let xs = polyXY.map(p => p[0]); // polyXY: Polygonã®ç”»åƒåº§æ¨™ãƒªã‚¹ãƒˆ
let ys = polyXY.map(p => p[1]);

let minX = Math.floor(Math.min(...xs));
let maxX = Math.ceil(Math.max(...xs));
let minY = Math.floor(Math.min(...ys));
let maxY = Math.ceil(Math.max(...ys));


for (let y = minY; y <= maxY; y++) {
  for (let x = minX; x <= maxX; x++) {
     if (isPointInPolygon(x, y, polyXY)) {
      if (map2D[y][x] != 0x81 && map2D[y][x] <= slidvalue) {
        // ã“ã“ãŒã€Œæ°´æ²¡ã‚»ãƒ«ã€
        // ä¾‹: map2D[y][x] = -10; // æ°´æ·±10mã§å¡—ã‚‹ã€è‰²åˆ†ã‘ç”¨ã®ãƒãƒ¼ã‚¯ã‚’ä»˜ä¸ãªã©
        koA+=1;
        koV +=((slidvalue+1)-(map2D[y][x])); 
        if (koL===0 || koL> map2D[y][x] ){
         koL=map2D[y][x];         //ãƒ€ãƒ 
        }
        map2D[y][x] = (200-(slidvalue-map2D[y][x]))&0xff; 
      }
    }
  }
}
function formatNumber(num, digits = 1) {
  return Number(num).toFixed(digits).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
const ene = ((slidvalue*10-83)*(koV*100)*9.8)/(3.6E12);
      document.getElementById('lH').textContent =  'æ¨™é«˜ã€€ã€€ï¼š'+formatNumber(slidvalue*10,0) + 'm';
     document.getElementById('damH').textContent = 'ãƒ€ãƒ å ¤é«˜ï¼š'+formatNumber((slidvalue-damH)*10,0) + 'm';
      document.getElementById('damL').textContent ='ãƒ€ãƒ é•·ã•ï¼š'+formatNumber(damL*10,0) + 'm';
      document.getElementById('koA').textContent = 'ãƒ€ãƒ æ¹–é¢ç©ï¼š'+formatNumber(koA*100,0) + 'ã¡';
      document.getElementById('koV').textContent = 'ãƒ€ãƒ æ¹–ä½“ç©ï¼š'+formatNumber(koV*100,0) + 'ã¥';
      document.getElementById('koL').textContent = 'ãƒ€ãƒ æ¹–æœ€æ·±ï¼š'+formatNumber((slidvalue-koL)*10,0) + 'm';
      document.getElementById('enegy').textContent = 'ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆGWhï¼‰ï¼š'+formatNumber((ene),2) + 'GWh';
//  <div class="info" id="enegy">ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆGWhï¼‰ï¼š-- m</div>


//---------------------------------------------------
// 1. ã¾ãšæ°´æ²¡ã‚»ãƒ«ã®ç¯„å›²ï¼ˆminX, maxX, minY, maxYï¼‰ã‚’æ±ºå®š
let lakePixels = [];
for (let y = 0; y < img.height; y++) {
  for (let x = 0; x < img.width; x++) {
    if (map2D[y][x]<=0 || map2D[y][x]>=128) { // isLake[y][x] ãŒtrueãªã‚‰æ°´æ²¡
      lakePixels.push([x, y]);
    }
  }
}
if (lakePixels.length === 0) {
  alert('æ°´æ²¡ã‚»ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ï¼');
  return;
  // ã¾ãŸã¯ return ã§é–¢æ•°çµ‚äº†
} 
if (!xs.length || !ys.length) {
  alert('xsã¾ãŸã¯ysãŒç©ºã§ã™ï¼lakePixels.length=' + lakePixels.length);
  return;
}

 minX = Math.max(0, Math.min(...xs));
maxX = Math.min(width-1, Math.max(...xs));
minY = Math.max(0, Math.min(...ys));
maxY = Math.min(height-1, Math.max(...ys));

const outW = maxX - minX + 1;
const outH = maxY - minY + 1;

// 2. æ–°ã—ã„canvasä½œæˆ
const outCanvas = document.createElement('canvas');
outCanvas.width = outW;
outCanvas.height = outH;
const outCtx = outCanvas.getContext('2d');
const outImage = outCtx.createImageData(outW, outH);

// 3. æ°´æ²¡ã‚»ãƒ«ã ã‘å…ƒç”»åƒã‹ã‚‰ã‚³ãƒ”ãƒ¼ã€ãã‚Œä»¥å¤–ã¯ã‚¢ãƒ«ãƒ•ã‚¡=0
for (let y = minY; y <= maxY; y++) {
  for (let x = minX; x <= maxX; x++) {
    const outIdx = ((y-minY)*outW + (x-minX)) * 4;
    if (map2D[y][x]==0x81 || map2D[y][x]>=128) {
      // ä¾‹: map2D[y][x]ã®å€¤ã§ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ« or ã‚«ãƒ©ãƒ¼
      let val = map2D[y][x];
      if(val==0x81){
        outImage.data[outIdx  ] = 0;
        outImage.data[outIdx+1] = 0;
        outImage.data[outIdx+2] = 0;
      }else{
        val=150+(val-200)*5;
        outImage.data[outIdx  ] = val;
        outImage.data[outIdx+1] = val;
        outImage.data[outIdx+2] = 255;
      }
        outImage.data[outIdx+3] = 255; // ä¸é€æ˜
    } else {
      outImage.data[outIdx  ] = 0;
      outImage.data[outIdx+1] = 0;
      outImage.data[outIdx+2] = 0;
      outImage.data[outIdx+3] = 0;   // å®Œå…¨é€æ˜
    }
  }
}
outCtx.putImageData(outImage, 0, 0);

// 4. ç”»é¢è¡¨ç¤ºã¾ãŸã¯PNGä¿å­˜
document.body.appendChild(outCanvas);
// PNGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
const link = document.createElement('a');
link.href = outCanvas.toDataURL('image/png');
link.download = 'lake_clip.png';
link.click();
const imageBounds = [
  [latMin, lngMin], // å—è¥¿ï¼ˆå·¦ä¸‹ï¼‰
  [latMax, lngMax]  // åŒ—æ±ï¼ˆå³ä¸Šï¼‰
];
//let lng1,lat1,lng2,lat2;
//XY2latlng(x, y, latMin, latMax, lngMin, lngMax, width, height)
  const [lat1,lng1] = XY2latlng(minX, minY, latMin, latMax, lngMin, lngMax, img.width, img.height);
  const [lat2,lng2] = XY2latlng(maxX, maxY, latMin, latMax, lngMin, lngMax, img.width, img.height);
  imageBounds[0]=[lat1,lng1 ];
  imageBounds[1]=[lat2,lng2] ;
L.imageOverlay(link.href , imageBounds, {

  opacity: 1
}).addTo(map);

clearLines(); //gamen clear
document.getElementById('damSwitch').checked=0;
  // ãƒ€ãƒ å»ºè¨­ãƒ¢ãƒ¼ãƒ‰ï¼ˆå ¤ä½“æŒ‡å®šãƒ»flood fillãªã©ï¼‰
  toggleDamMode(document.getElementById('damSwitch').checked);



}
//---------------------------------------------------

/*


let damDots = 0, lakeDots = 0, maxDepth = 0, totalVolume = 0;
for (let y = minY; y <= maxY; y++) {
  for (let x = minX; x <= maxX; x++) {
    if (isDam[y][x]) damDots++;
    if (isLake[y][x]) {
      lakeDots++;
      let depth = waterLevel - originalElevation[y][x];
      if (depth > maxDepth) maxDepth = depth;
      totalVolume += pixelArea * depth;
    }
  }
}



 const canvas = document.createElement('canvas');
canvas.width = map2D[0].length;   // width map2D[0].length
canvas.height =  map2D.length; // height map2D.length
const ctx = canvas.getContext('2d');
const imageData = ctx.createImageData(canvas.width, canvas.height);
for (let y = 0; y < canvas.height; y++) {
  for (let x = 0; x < canvas.width; x++) {
    const idx = (y * width + x) * 4;
    let val = map2D[y][x];

    // ä¾‹ï¼š8bitå€¤ã¨ã—ã¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«è¡¨ç¤ºï¼ˆ-127ãªã©è² å€¤ã¯è‰²åˆ†ã‘ã‚‚OKï¼‰
    if (val < 0) val = 255;  // ãŸã¨ãˆã°ãƒ€ãƒ å ¤ä½“ï¼ˆ-127ï¼‰ã¯ç™½ã§
    imageData.data[idx  ] = val; // R
    imageData.data[idx+1] = val; // G
    imageData.data[idx+2] = val; // B
    imageData.data[idx+3] = 255; // A
  }
}
ctx.putImageData(imageData, 0, 0);
document.body.appendChild(canvas);

const link = document.createElement('a');
link.href = canvas.toDataURL('image/png');
link.download = 'map2d_result.png'; // å¥½ããªãƒ•ã‚¡ã‚¤ãƒ«åã«
link.click();
/*          
 for (let y = minY; y <= maxY; y++) {
   for (let x = minX; x <= maxX; x++) {
    // ã‚»ãƒ«ä¸­å¿ƒåº§æ¨™â†’ç·¯åº¦çµŒåº¦ã«å¤‰æ›
    let [lat, lng] = xyToLatLng(x, y);//, ...);
    // Polygonå†…åˆ¤å®š
    if (isPointInPolygon([lat, lng], polygon)) {
      // Polygonå†…å‡¦ç†
    }
    // Polygonã®å„è¾ºã§Polylineä¸Šåˆ¤å®š
    for (let i = 0; i < polygon.length; i++) {
      let j = (i + 1) % polygon.length;
      if (isPointOnLineSegment([lat, lng], polygon[i], polygon[j], tolerance)) {
        // Polylineä¸Šå‡¦ç†ï¼ˆãƒ€ãƒ ã‚»ãƒ«ç­‰ï¼‰
      }
    }
  }
 }
*/


//----------------------------------------------------------
/*
// å…¥åŠ›: lat, lng
// ç”»åƒç¯„å›²:
const latMin = 34.7500;
const latMax = 35.7500;
const lngMin = 135.7500;
const lngMax = 136.5000;

// ãƒãƒƒãƒ—ã‚µã‚¤ã‚º
const width = 6750;
const height = 9000;

// è¨ˆç®—ï¼ˆç”»åƒåº§æ¨™åŸç‚¹ãŒå·¦ä¸Šã®å ´åˆï¼‰
const x = Math.round((lng - lngMin) / (lngMax - lngMin) * (width - 1));
const y = Math.round((latMax - lat) / (latMax - latMin) * (height - 1));
x: å·¦ç«¯ï¼ˆè¥¿ï¼‰ãŒ0ã€å³ç«¯ï¼ˆæ±ï¼‰ãŒwidth-1

y: ä¸Šç«¯ï¼ˆåŒ—ï¼‰ãŒ0ã€ä¸‹ç«¯ï¼ˆå—ï¼‰ãŒheight-1


// å…¥åŠ›: x, y
const lng = lngMin + (x / (width - 1)) * (lngMax - lngMin);
const lat = latMax - (y / (height - 1)) * (latMax - latMin);
x, yã‹ã‚‰lat/lngã‚’å–å¾—




*/



</script>
</body>
</html>
